name: build-and-deploy
on:
  push:
    branches: ["master"]

permissions:
  contents: read
  packages: write

env:
  NAMESPACE: mlops
  APP_NAME: myapp     # 배포 리소스(Deployment 등)에서 쓰는 이름
  IMAGE_REPO: ghcr.io/${{ github.repository }}  # ghcr.io/owner/repo
  IMAGE_TAG: ${{ github.sha }}
  IMAGE: ghcr.io/${{ github.repository }}:${{ github.sha }}

jobs:
  build-and-deploy:
    runs-on: self-hosted   # 네 k8s gh-runner 파드에서 실행됨
    steps:
      - uses: actions/checkout@v4

      - name: Kube context 확인
        run: kubectl version --short && kubectl get ns

      # GHCR 로그인용 docker-registry secret을 K8s에 생성/갱신
      - name: Ensure GHCR docker secret
        run: |
          kubectl -n "$NAMESPACE" create secret docker-registry ghcr-creds \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}" \
            --docker-email="ci@example.local" \
            --dry-run=client -o yaml | kubectl apply -f -

      # 이전 Kaniko 잡 정리 (재실행시 충돌 피함)
      - name: Cleanup previous Kaniko Job
        run: |
          kubectl -n "$NAMESPACE" delete job kaniko-build --ignore-not-found=true

      # Kaniko Job 생성 (Git URL을 컨텍스트로 사용)
      # 레포가 private이면 x-access-token + GITHUB_TOKEN 포함한 HTTPS URL 사용
      - name: Launch Kaniko Job
        run: |
          GIT_URL="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git#${{ github.sha }}"
          cat <<'YAML' | envsubst | kubectl -n "$NAMESPACE" apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: kaniko-build
          spec:
            backoffLimit: 0
            template:
              spec:
                restartPolicy: Never
                containers:
                  - name: kaniko
                    image: gcr.io/kaniko-project/executor:latest
                    args:
                      - --context=${GIT_URL}
                      - --dockerfile=Dockerfile
                      - --destination=${IMAGE}
                      # 캐시를 쓰고 싶다면 아래 두 줄 주석 해제 (옵션)
                      # - --cache=true
                      # - --cache-repo=${IMAGE_REPO}-cache
                    env:
                      # 프록시/빌드아규먼트가 필요하면 여기 추가
                      # - name: HTTP_PROXY
                      #   value: ...
                      # - name: HTTPS_PROXY
                      #   value: ...
                      # - name: NO_PROXY
                      #   value: ...
                    volumeMounts:
                      - name: docker-config
                        mountPath: /kaniko/.docker/
                volumes:
                  - name: docker-config
                    secret:
                      secretName: ghcr-creds
                      items:
                        - key: .dockerconfigjson
                          path: config.json
          YAML

      # Kaniko Job 완료 대기 + 로그 확인
      - name: Wait for Kaniko build to finish
        run: |
          kubectl -n "$NAMESPACE" wait --for=condition=Complete job/kaniko-build --timeout=20m
          POD=$(kubectl -n "$NAMESPACE" get pods -l job-name=kaniko-build -o jsonpath='{.items[0].metadata.name}')
          echo "== Kaniko Logs =="
          kubectl -n "$NAMESPACE" logs "$POD"

      # 배포 매니페스트 이미지 태그 치환 후 적용
      - name: Update image in manifest and apply
        run: |
          # 예: k8s/deploy.yaml 내 첫 번째 컨테이너 이미지 교체
          yq -i '.spec.template.spec.containers[0].image = strenv(IMAGE)' k8s/deploy.yaml
          kubectl -n "$NAMESPACE" apply -f k8s/deploy.yaml

      # 롤아웃 확인(Deployment 기준). 리소스명이 다르면 수정
      - name: Wait for rollout
        run: |
          kubectl -n "$NAMESPACE" rollout status deploy/${{ env.APP_NAME }} --timeout=5m

