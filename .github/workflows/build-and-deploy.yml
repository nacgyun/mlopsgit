name: Train with MLflow (Runtime image on demand, always retrain from git)

on:
  workflow_dispatch:
  push:
    branches: [ master ]

jobs:
  train-build-run:
    runs-on: [self-hosted, k8s]

    env:
      NAMESPACE: mlops
      IMAGE_RUNTIME: ghcr.io/${{ github.repository }}:runtime
      TRAIN_JOB_NAME: train-job

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install kubectl if missing
        run: |
          set -e
          if ! command -v kubectl >/dev/null 2>&1; then
            ARCH=$(uname -m); case "$ARCH" in x86_64) ARCH=amd64;; aarch64) ARCH=arm64;; esac
            curl -sSL -o kubectl "https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/${ARCH}/kubectl"
            chmod +x kubectl && sudo mv kubectl /usr/local/bin/kubectl
          fi
          kubectl version --client=true

      - name: Set variables
        run: |
          echo "GIT_SHA=${GITHUB_SHA}" >> $GITHUB_ENV
          echo "SHORT_SHA=$(echo ${GITHUB_SHA} | cut -c1-12)" >> $GITHUB_ENV
          echo "REPO=${GITHUB_REPOSITORY}" >> $GITHUB_ENV

      - name: Detect changes for runtime image
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            runtime_image:
              - 'Dockerfile.runtime'
              - 'ml/requirements.txt'

      # ===== Kaniko (런타임 이미지 빌드) — 변경 있을 때만 실행 =====
      - name: Kaniko runtime-build (inline manifest → pipe to kubectl)
        if: steps.changes.outputs.runtime_image == 'true'
        env:
          JOB_NAME: kaniko-build-${{ github.run_id }}
        run: |
          set -euxo pipefail
          : "${JOB_NAME:?empty}"
          : "${IMAGE_RUNTIME:?empty}"
          : "${GIT_SHA:?empty}"
          : "${NAMESPACE:?empty}"

          # 인라인 매니페스트 (generateName 대신 고정 name 사용)
          # - 비공개 레포 tarball 다운로드 위해 initContainer에 gh-pat 주입
          # - Dockerfile.runtime 고정 사용 (템플릿/치환 없음)
          MANIFEST="$(cat <<YAML
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${JOB_NAME}
            namespace: ${NAMESPACE}
            labels:
              app: kaniko-build
          spec:
            backoffLimit: 0
            ttlSecondsAfterFinished: 600
            template:
              metadata:
                labels:
                  app: kaniko-build
                  job-name: ${JOB_NAME}
              spec:
                restartPolicy: Never

                volumes:
                  - name: docker-config
                    secret:
                      secretName: ghcr-creds
                      items:
                        - key: .dockerconfigjson
                          path: config.json
                  - name: workspace
                    emptyDir: {}

                initContainers:
                  - name: fetch-src
                    image: alpine:3.20
                    command: ["/bin/sh","-lc"]
                    env:
                      - name: GITHUB_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: gh-pat
                            key: PAT
                    args:
                      - |
                        set -e
                        apk add --no-cache curl tar ca-certificates >/dev/null
                        update-ca-certificates || true
                        echo "download source for ${GIT_SHA}"
                        curl -sS -L -H "Authorization: Bearer \${GITHUB_TOKEN}" \
                          -o /tmp/src.tgz "https://codeload.github.com/${{ github.repository }}/tar.gz/${GIT_SHA}"
                        mkdir -p /workspace
                        tar -xzf /tmp/src.tgz -C /workspace --strip-components=1
                        ls -al /workspace | head -n 50
                    volumeMounts:
                      - name: workspace
                        mountPath: /workspace

                containers:
                  - name: kaniko
                    image: gcr.io/kaniko-project/executor:latest
                    imagePullPolicy: IfNotPresent
                    args:
                      - --context=/workspace
                      - --dockerfile=/workspace/Dockerfile.runtime
                      - --destination=${IMAGE_RUNTIME}
                      - --cache=true
                      - --cache-repo=ghcr.io/${{ github.repository }}/cache
                    volumeMounts:
                      - name: docker-config
                        mountPath: /kaniko/.docker/
                      - name: workspace
                        mountPath: /workspace
          YAML
          )"

          echo "----- Kaniko Job (rendered) -----"
          echo "${MANIFEST}"

          # 과거 동일 이름 Job 남아 있으면 정리(실패 무시)
          kubectl -n "${NAMESPACE}" delete job "${JOB_NAME}" --ignore-not-found || true

          # 적용 → 대기 → 로그
          echo "${MANIFEST}" | kubectl apply -f -
          kubectl -n "${NAMESPACE}" wait --for=condition=complete --timeout=30m job/${JOB_NAME}
          POD=$(kubectl -n "${NAMESPACE}" get pod -l job-name="${JOB_NAME}" -o jsonpath='{.items[0].metadata.name}')
          kubectl -n "${NAMESPACE}" logs "${POD}" --tail=300 || true

      # ===== Train Job (항상 최신 커밋으로 실행) =====
      - name: Render Train Job manifest
        run: |
          set -e
          sed -e "s|__IMAGE__|${IMAGE_RUNTIME}|g" \
              -e "s|__GIT_SHA__|${GIT_SHA}|g" \
            k8s/train-job.yaml.tmpl > k8s/train-job.yaml
          echo "----- k8s/train-job.yaml -----"
          cat k8s/train-job.yaml

      - name: Cleanup previous Train Job
        run: |
          set -e
          kubectl -n "$NAMESPACE" delete job "$TRAIN_JOB_NAME" --ignore-not-found --wait=true || true

      - name: Apply Train Job
        run: |
          set -e
          kubectl -n "$NAMESPACE" apply -f k8s/train-job.yaml
          kubectl -n "$NAMESPACE" get pods -l job-name="$TRAIN_JOB_NAME" -o wide

      - name: Wait Train → logs
        run: |
          set -e
          kubectl -n "$NAMESPACE" wait --for=condition=complete --timeout=60m job/${TRAIN_JOB_NAME}
          POD=$(kubectl -n "$NAMESPACE" get pod -l job-name="${TRAIN_JOB_NAME}" -o jsonpath='{.items[0].metadata.name}')
          kubectl -n "$NAMESPACE" logs "$POD" --tail=300 || true

